##工厂方法模式

###定义

>定义一个用于创建对象的接口,让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

###使用场景

1.简单工厂模式

>工厂类中包含了必要的逻辑判断,根据客户端的选择条件动态实例化相关的类,对于客户端
来说,去除了与具体产品的依赖。

>但是,当需要增加新的功能类时,我们除了要定义功能类外,还要在工厂类里面加入case分支条件
判断,修改原有的类,这就等于不但对扩展开放了(新增功能类),而且对修改也开放了(工厂类里增加case分支判断),
很明显违背了开放-封闭原则。

2.工厂方法模式

>把工厂类与分支的耦合解除,根据依赖转换原则,把原有的工厂类抽象出一个接口,这个接口只有一个方法,
就是创建抽象产品的工厂方法。然后,所有的要生产具体类的工厂,就去实现这个接口,这样,一个简单工厂
模式的工厂类就变成了一个抽象接口和多个具体生成对象的工厂,于是我们要增加新的功能类时,就不需要更改
原有的工厂类了,只需要增加此功能的运算类和相应的工厂类就可以了。

>这样就达到了只对扩展变化,而不对修改变化,完全符合开放-封闭原则。

>还有就是在工厂方法模式实现时,客户端需要决定实例化哪一个工厂来实现运算类,选择判断的
问题还是存在的,也就是说,工厂方法模式把简单工厂模式的内部逻辑判断转移到了客户端代码来进行。你想要加功能,
本来是修改工厂类,而现在是在修改客户端。